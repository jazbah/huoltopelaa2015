<?php
/**
 * @file
 * template.php
 */

/**
 * Implements hook_css_alter().
 */
function huoltopelaa2015_css_alter(&$css) {
  // single_css means we work in a production environment, so we analyse the
  // list of CSS and include only the ones we need.
  if (variable_get('single_css', TRUE)) {

    $whitelist = array(
      'sites/all/libraries/datetimepicker/jquery.datetimepicker.css',
    );

    // Here we do a whitelist only on our file and inline CSS
    $theme_path = drupal_get_path('theme', 'huoltopelaa2015');
    foreach ($css as $name => $settings) {
      if ($settings['type'] == 'inline' || $name == $theme_path . '/dist/style.min.css') {
        // This will disable @import commands, better for caching HTTP requests
        $css[$name]['preprocess'] = FALSE;
      }
      elseif (!in_array($name, $whitelist, TRUE)) {
        unset($css[$name]);
      }
    }

  }
}




/**
 * Implements hook_js_alter().
 */
function huoltopelaa2015_js_alter(&$js) {
  $theme_path = drupal_get_path('theme', 'huoltopelaa2015');

  // The whitelist in case of single_js == TRUE, the blacklist otherwise
  $whitelist = array(
    "sites/all/libraries/datetimepicker/jquery.datetimepicker.js",
    drupal_get_path('module', 'mon_scheduler') . '/mon_scheduler.js',
  );

  // single_js means we work in a production environment, so include only
  // our single JS file, generated by gulp, and some whitelisted ones
  if (variable_get('single_js', TRUE)) {

    foreach ($js as $name => $settings) {
      // Exclude all files except for our own, and Drupal.settings
      if ($name != 'settings' && $name != $theme_path . '/dist/script.min.js' && !in_array($name, $whitelist, TRUE)) {
        unset($js[$name]);
      }
    }

    // Change its group and weight to be the first one included.
    // In that way, all other scripts whitelisted don't have to take care about
    // group and weight regarding to this global aggregate scripts which may
    // contains libraries.
    $js[$theme_path . '/dist/script.min.js']['group'] = JS_DEFAULT;
    $js[$theme_path . '/dist/script.min.js']['weight'] = -100;
  }
  else {
    // On development environments, we will try to populate the map.json file
    // with JS files that are included on the fly, excluding the one we generated
    $path = $theme_path . '/js/map.json';

    // Load previous list from map.json
    $contents = file_get_contents($path);
    $list = FALSE;
    if ($contents !== FALSE) {
      // We have a list, parse it
      $list = drupal_json_decode($contents);
    }
    // else reading file failed, and we won't update it programmatically, but
    // we will still remove our single file

    foreach ($js as $name => $settings) {
      if ($name == $theme_path . '/dist/script.min.js') {
        // We won't need our single file here
        unset($js[$name]);
        continue;
      }

      // If we have a list, update it
      if ($list !== FALSE && $name != 'settings' && !in_array($name, $whitelist, TRUE) && strstr($name, 'languages/fr') === FALSE) {
        // TRUE will add it, FALSE will remove it, edit the map.json file
        // directly if you need to exclude a file
        $list[$name] = isset($list[$name]) ? $list[$name] : TRUE;
      }

    }
    // Udpate map.json
    if ($list !== FALSE && defined('JSON_PRETTY_PRINT')) {
      file_put_contents($path, json_encode($list, JSON_PRETTY_PRINT) . "\n");
    }
  }
}